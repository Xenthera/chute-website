<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chute - Peer-to-Peer File Transfer</title>
  <meta name="description" content="Chute is a fast, secure peer-to-peer file transfer application. Send files directly between devices without cloud storage.">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --surface: #eef0f3;
      --shadow-dark: rgba(150, 160, 170, 0.75);
      --shadow-light: rgba(255, 255, 255, 0.98);
      --chute-door-stroke: #b6bcc4;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Nunito', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top left, #f8faff, #cfd4df);
      color: #4a4f57;
      padding: 2rem;
    }

    .container {
      text-align: center;
      max-width: 700px;
      width: 100%;
    }

    .funnel {
      width: min(560px, 90%);
      aspect-ratio: 16 / 9;
      height: auto;
      background: var(--surface);
      border-radius: 28px;
      box-shadow: 8px 8px 16px var(--shadow-dark), -8px -8px 16px var(--shadow-light);
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 2rem;
    }

    .funnel-inner {
      position: absolute;
      inset: 24px;
      background: var(--surface);
      border-radius: 18px;
      z-index: 1;
      overflow: hidden;
    }

    .funnel-inner::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 18px;
      box-shadow: inset 10px 10px 18px var(--shadow-dark),
        inset -10px -10px 18px var(--shadow-light);
      z-index: 2;
      pointer-events: none;
    }

    .funnel-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border-radius: 18px;
    }

    h1 {
      font-size: 72px;
      font-weight: 900;
      letter-spacing: 4px;
      transform: scaleX(0.92);
      text-transform: uppercase;
      color: #b3b7bf;
      text-shadow: none;
      line-height: 1;
      margin: 0 0 1rem 0;
    }

    .tagline {
      font-size: 1.25rem;
      color: #7b818b;
      font-weight: 300;
      margin-bottom: 2rem;
    }

    .status {
      display: inline-block;
      padding: 0.75rem 1.5rem;
      background: linear-gradient(180deg, #eef0f3 0%, #e6e8ec 100%);
      border-radius: 12px;
      font-size: 0.9rem;
      color: #5c6f7c;
      font-weight: 400;
      letter-spacing: 0.5px;
      box-shadow: 
        4px 4px 8px rgba(150, 160, 170, 0.3),
        -4px -4px 8px rgba(255, 255, 255, 0.8);
    }

    .status::before {
      content: '';
      display: inline-block;
      width: 8px;
      height: 8px;
      background: #f59e0b;
      border-radius: 50%;
      margin-right: 8px;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .features {
      margin-top: 2.5rem;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 1.5rem;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    .feature {
      text-align: center;
      padding: 1rem 0.5rem;
    }

    .feature-icon {
      width: 32px;
      height: 32px;
      margin: 0 auto 0.75rem;
      color: #9ca3af;
    }

    .feature-icon svg {
      width: 100%;
      height: 100%;
      stroke: currentColor;
      stroke-width: 1.5;
      fill: none;
    }

    .feature-text {
      font-size: 0.8rem;
      color: #7b818b;
      font-weight: 400;
      letter-spacing: 0.3px;
    }

    .disclaimer {
      margin-top: 3rem;
      padding: 2rem 1.5rem;
    }

    .disclaimer p {
      max-width: 800px;
      margin: 0 auto;
      font-size: 11px;
      line-height: 1.5;
      color: #86868b;
      text-align: center;
    }

    .disclaimer p + p {
      margin-top: 0.5rem;
    }

    .disclaimer .copyright {
      margin-top: 1rem;
      font-size: 12px;
      color: #9ca3af;
    }

  </style>
</head>
<body>
  <div class="container">
    <h1>Chute</h1>
    
    <div class="funnel">
      <div class="funnel-inner">
        <canvas id="chute-canvas" class="funnel-canvas"></canvas>
      </div>
    </div>
    
    <p class="tagline">Send files directly. No cloud, no limits.</p>
    
    <span class="status">Coming Soon</span>
    
    <div class="features">
      <div class="feature">
        <div class="feature-icon">
          <svg viewBox="0 0 24 24"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
        </div>
        <div class="feature-text">End-to-End Encrypted</div>
      </div>
      <div class="feature">
        <div class="feature-icon">
          <svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>
        </div>
        <div class="feature-text">Direct Connection</div>
      </div>
      <div class="feature">
        <div class="feature-icon">
          <svg viewBox="0 0 24 24"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
        </div>
        <div class="feature-text">No File Size Limits</div>
      </div>
      <div class="feature">
        <div class="feature-icon">
          <svg viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/><line x1="1" y1="1" x2="23" y2="23"/></svg>
        </div>
        <div class="feature-text">Private by Design</div>
      </div>
      <div class="feature">
        <div class="feature-icon">
          <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></svg>
        </div>
        <div class="feature-text">Works Anywhere</div>
      </div>
      <div class="feature">
        <div class="feature-icon">
          <svg viewBox="0 0 24 24"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>
        </div>
        <div class="feature-text">Cross-Platform</div>
      </div>
    </div>
  </div>

  <div class="disclaimer">
    <p>Chute enables direct file transfers between devices. Files are sent directly from sender to recipient — we cannot see, access, or store any transferred content. You are solely responsible for the files you send and receive.</p>
    <p>Do not use Chute for illegal purposes, including but not limited to transferring copyrighted material without authorization, malware, or any content that violates applicable laws. By using Chute, you agree to comply with all applicable laws and accept full responsibility for your actions. Chute and its developers assume no liability for misuse.</p>
    <p class="copyright">© 2026 Chute. All rights reserved.</p>
  </div>
  
  <script>
    class ChuteCanvas {
      constructor(canvas) {
        const ctx = canvas.getContext("2d");
        if (!ctx) throw new Error("Failed to acquire canvas context.");
        this.canvas = canvas;
        this.ctx = ctx;
        this.doorTarget = 1; // Start open
        this.doorProgress = 1;
        this.rafId = null;
        this.lerpFactor = 0.08;
        this.tunnelSpeed = 0.44;
        this.tunnelRadius = 18;
        this.ringLineWidth = 2;
        this.pulseDirection = "in";
        this.pulseColors = {
          base: { r: 130, g: 130, b: 130 },
          glow: { r: 80, g: 255, b: 255 },
        };
        this.cachedWidth = 0;
        this.cachedHeight = 0;
        this.particles = [];
        this.particleCount = 30;
        this.particleSpawnRate = 0.02;

        this.handleResize = this.resize.bind(this);
        this.resize();
        window.addEventListener("resize", this.handleResize);
      }

      start() {
        if (this.rafId !== null) return;
        this.particles = [];
        for (let i = 0; i < this.particleCount; i++) {
          this.particles.push({
            x: Math.random() * this.cachedWidth,
            y: Math.random() * this.cachedHeight,
            z: Math.random(),
            speed: 0.01 + Math.random() * 0.02,
            size: 1 + Math.random() * 2,
          });
        }
        const tick = (now) => {
          this.render(now);
          this.rafId = requestAnimationFrame(tick);
        };
        this.rafId = requestAnimationFrame(tick);
      }

      resize() {
        const rect = this.canvas.getBoundingClientRect();
        this.cachedWidth = rect.width;
        this.cachedHeight = rect.height;
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = Math.max(1, Math.floor(rect.width * dpr));
        this.canvas.height = Math.max(1, Math.floor(rect.height * dpr));
        this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        this.ctx.clearRect(0, 0, rect.width, rect.height);
      }

      render(now) {
        this.doorProgress += (this.doorTarget - this.doorProgress) * this.lerpFactor;
        if (Math.abs(this.doorTarget - this.doorProgress) < 0.001) {
          this.doorProgress = this.doorTarget;
        }
        let tunnelPhase = ((now / 1000) * this.tunnelSpeed) % 1;
        if (tunnelPhase < 0) tunnelPhase += 1;
        this.updateParticles();
        this.drawFunnelDoors(this.cachedWidth, this.cachedHeight, this.doorProgress, tunnelPhase);
      }

      updateParticles() {
        const width = this.cachedWidth;
        const height = this.cachedHeight;
        if (width === 0 || height === 0) return;

        for (let i = 0; i < this.particles.length; i++) {
          const p = this.particles[i];
          if (this.pulseDirection === "in") {
            p.z += p.speed;
            if (p.z >= 1) {
              p.z = 0;
              p.x = Math.random() * width;
              p.y = Math.random() * height;
            }
          } else {
            p.z -= p.speed;
            if (p.z <= 0) {
              p.z = 1;
              p.x = Math.random() * width;
              p.y = Math.random() * height;
            }
          }
        }

        if (Math.random() < this.particleSpawnRate && this.particles.length < this.particleCount * 1.5) {
          this.particles.push({
            x: Math.random() * width,
            y: Math.random() * height,
            z: this.pulseDirection === "in" ? 0 : 1,
            speed: 0.01 + Math.random() * 0.02,
            size: 1 + Math.random() * 2,
          });
        }
      }

      getSurfaceColor() {
        return getComputedStyle(document.body).getPropertyValue("--surface").trim() || "#e7edf4";
      }

      getDoorStrokeColor() {
        return getComputedStyle(document.body).getPropertyValue("--chute-door-stroke").trim() || "#b6bcc4";
      }

      drawRoundedRect(x, y, width, height, radius) {
        const r = Math.max(0, Math.min(radius, Math.min(width, height) / 2));
        this.ctx.beginPath();
        this.ctx.moveTo(x + r, y);
        this.ctx.lineTo(x + width - r, y);
        this.ctx.quadraticCurveTo(x + width, y, x + width, y + r);
        this.ctx.lineTo(x + width, y + height - r);
        this.ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
        this.ctx.lineTo(x + r, y + height);
        this.ctx.quadraticCurveTo(x, y + height, x, y + height - r);
        this.ctx.lineTo(x, y + r);
        this.ctx.quadraticCurveTo(x, y, x + r, y);
        this.ctx.closePath();
      }

      drawTunnel(width, height, phase) {
        this.ctx.fillStyle = "#0a0f16";
        this.ctx.fillRect(0, 0, width, height);

        const rings = 20;
        const minSize = Math.min(width, height);
        const baseRings = 10;
        const baseGap = Math.max(6, minSize / (baseRings * 1.4));
        const desiredMaxInset = (baseRings - 1) * baseGap + 2;
        const gap = Math.max(4, (desiredMaxInset - 2) / (rings - 1));
        const glowColor = this.pulseColors.glow;

        this.ctx.save();
        this.ctx.lineWidth = this.ringLineWidth;
        const ringCornerRadius = this.tunnelRadius;

        for (let i = 0; i < rings; i++) {
          const inset = i * gap + 2;
          const ringWidth = Math.max(0, width - inset * 2);
          const ringHeight = Math.max(0, height - inset * 2);
          if (ringWidth <= 0 || ringHeight <= 0) continue;

          const normalizedPos = i / (rings - 1);
          let phaseOffset = i * 0.12;
          if (this.pulseDirection === "in") {
            phaseOffset *= 1 + normalizedPos * 0.8;
          } else {
            phaseOffset *= 1 + (1 - normalizedPos) * 0.8;
          }

          let localPhase;
          if (this.pulseDirection === "in") {
            localPhase = ((1 - phase + phaseOffset) % 1 + 1) % 1;
          } else {
            localPhase = ((phase + phaseOffset) % 1 + 1) % 1;
          }
          const glow = Math.max(0, Math.sin(localPhase * Math.PI * 2));

          const fadeToCenter = Math.max(0, 1 - (i / (rings - 1)) * 1.5);
          if (fadeToCenter <= 0) continue;

          const offAlpha = 0.14;
          const alpha = offAlpha + (fadeToCenter - offAlpha) * glow;
          const r = Math.round(glowColor.r);
          const g = Math.round(glowColor.g);
          const b = Math.round(glowColor.b);
          this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
          this.drawRoundedRect(inset, inset, ringWidth, ringHeight, ringCornerRadius);
          this.ctx.stroke();
        }

        this.ctx.restore();
        this.drawParticles(width, height);
      }

      drawParticles(width, height) {
        const particleColor = this.pulseDirection === "in"
          ? { r: 80, g: 255, b: 255 }
          : { r: 255, g: 150, b: 60 };

        const centerX = width / 2;
        const centerY = height / 2;

        for (const p of this.particles) {
          const depthFactor = this.pulseDirection === "in" ? p.z : 1 - p.z;
          const size = p.size * 0.5;
          const opacity = 1 - p.z;
          const projectionFactor = this.pulseDirection === "in" ? (1 - depthFactor) : depthFactor;
          const projectedX = centerX + (p.x - centerX) * projectionFactor;
          const projectedY = centerY + (p.y - centerY) * projectionFactor;

          this.ctx.fillStyle = `rgba(${particleColor.r}, ${particleColor.g}, ${particleColor.b}, ${opacity})`;
          this.ctx.beginPath();
          this.ctx.arc(projectedX, projectedY, size, 0, Math.PI * 2);
          this.ctx.fill();
        }
      }

      drawFunnelDoors(width, height, doorProgress, tunnelPhase) {
        this.ctx.clearRect(0, 0, width, height);
        this.drawTunnel(width, height, tunnelPhase);

        const doorColor = this.getSurfaceColor();
        const borderColor = this.getDoorStrokeColor();
        const half = width / 2;

        const offset = half * doorProgress;
        const leftX = -offset;
        const rightX = half + offset;
        const doorY = -2;
        const doorHeight = height + 4;

        this.ctx.fillStyle = doorColor;
        this.ctx.fillRect(leftX, doorY, half, doorHeight);
        this.ctx.fillRect(rightX, doorY, half, doorHeight);

        this.ctx.strokeStyle = borderColor;
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(leftX + 0.5, doorY + 0.5, half - 1, doorHeight - 1);
        this.ctx.strokeRect(rightX + 0.5, doorY + 0.5, half - 1, doorHeight - 1);
      }
    }

    // Initialize the chute canvas
    const canvas = document.getElementById("chute-canvas");
    const chute = new ChuteCanvas(canvas);
    chute.start();
  </script>
</body>
</html>
